<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>JPA 영속성 컨텍스트(Persistence Context) </title>
    <link rel="stylesheet" href="/src/css/study.css">

</head>
<body>
<h1>JPA 영속성 컨텍스트(Persistence Context)</h1>
<section>
    <h2>1) 영속성 컨텍스트(Persistence Context)란?</h2>
    <ul>
        <li><strong>정의:</strong> 엔터티(Entity)를 저장하고 관리하는 JPA의 내부 메모리 영역.</li>
        <li>EntityManager(또는 Spring Data JPA 내부 EntityManager)가 엔터티를 <strong>관리 상태(managed)</strong>로 두는 저장소이다.</li>
        <li>즉, JPA가 DB와 직접 접근하지 않고, <strong>중간 캐시(1차 캐시)</strong> 역할을 하는 영역이다.</li>
        <li>엔터티가 영속성 컨텍스트에 저장되면, JPA는 해당 객체의 상태 변화를 감지하고 자동으로 DB에 반영한다.</li>
    </ul>
</section>

<section>
    <h2>2) 영속성 컨텍스트를 사용하는 이유</h2>
    <ul>
        <li><strong>1차 캐시</strong>: 같은 트랜잭션 내에서 같은 엔터티를 여러 번 조회해도 DB를 다시 조회하지 않고 메모리에서 재사용한다.</li>
        <li><strong>쓰기 지연 (Write-Behind)</strong>: 여러 엔터티 저장을 모았다가 트랜잭션 커밋 시 한 번에 DB에 반영한다.</li>
        <li><strong>변경 감지 (Dirty Checking)</strong>: 관리 중인 엔터티의 필드가 변경되면 JPA가 자동으로 UPDATE SQL을 생성한다.</li>
        <li><strong>트랜잭션 단위 관리</strong>: 같은 트랜잭션 내에서 동일한 엔터티는 항상 같은 객체(동일성 보장)로 관리된다.</li>
    </ul>
</section>

<section>
    <h2>3) 언제 생성되고 언제 종료되는가</h2>
    <ul>
        <li>영속성 컨텍스트는 <strong>트랜잭션 시작 시 생성되고, 커밋 또는 롤백 시 종료</strong>된다.</li>
        <li>Spring Data JPA에서는 서비스 계층의 <code>@Transactional</code> 단위로 자동 관리된다.</li>
        <li>트랜잭션이 끝나면 영속성 컨텍스트도 사라지고, 엔터티는 더 이상 관리되지 않는 “준영속(detached)” 상태가 된다.</li>
    </ul>
</section>

<section>
    <h2>4) save() 호출 시 동작 과정</h2>
    <ul>
        <li><strong>save()</strong>는 내부적으로 EntityManager의 <code>persist()</code> 또는 <code>merge()</code>를 호출한다.</li>
        <li><code>persist()</code>: 새 엔터티(식별자 없음)를 영속성 컨텍스트에 등록 → INSERT SQL 예약</li>
        <li><code>merge()</code>: 이미 존재하는 엔터티(식별자 있음)를 영속성 컨텍스트에 병합 → UPDATE SQL 예약</li>
    </ul>
    <pre><code>@Service
public class EmpService {
  private final EmpRepository empRepository;

  public EmpService(EmpRepository empRepository) {
    this.empRepository = empRepository;
  }

  @Transactional
  public void register() {
    Emp emp = new Emp();
    emp.setEmpno(8000);
    emp.setEname("LEE");
    emp.setJob("SALESMAN");
    empRepository.save(emp); // persist() 호출 → 1차 캐시에 저장됨
    // 아직 DB 반영 전 (쓰기 지연 상태)
  }
}</code></pre>
    <ul>
        <li><strong>트랜잭션이 커밋될 때</strong> JPA는 1차 캐시를 검사하여 변경된 내용을 SQL로 반영한다.</li>
        <li>따라서 save() 직후 DB에 즉시 INSERT되지 않을 수도 있다 (트랜잭션 커밋 시점에 반영).</li>
    </ul>
</section>

<section>
    <h2>5) 영속성 컨텍스트의 상태 변화</h2>
    <ul>
        <li><strong>비영속(new)</strong>: 엔터티가 아직 JPA와 관계없는 상태</li>
        <li><strong>영속(managed)</strong>: EntityManager에 저장되어 관리 중 (1차 캐시에 존재)</li>
        <li><strong>준영속(detached)</strong>: 영속성 컨텍스트에서 분리됨 (더 이상 변경 감지 X)</li>
        <li><strong>삭제(removed)</strong>: 삭제 예약 상태 (commit 시 DELETE SQL 실행)</li>
    </ul>
    <pre><code>@PersistenceContext
private EntityManager em;  // 영속성 컨텍스트를 관리하는 핵심 객체

public void testEntityState() {
    // 1) 비영속 상태 (아직 JPA와 관계없음)
    Emp emp = new Emp(7788, "SCOTT", "ANALYST");

    // 2) 영속 상태 진입 - 영속성 컨텍스트에 등록
    em.persist(emp);
    // 이제 emp는 영속성 컨텍스트(1차 캐시)에서 관리됨
    // 이후 변경 감지가 적용됨
    emp.setJob("MANAGER"); // Dirty Checking → commit 시 UPDATE 실행

    // 3) 준영속 상태로 전환 (더 이상 관리하지 않음)
    em.detach(emp);
    emp.setJob("SALESMAN"); // 변경 감지되지 않음 (UPDATE X)

    // 4) 삭제 예약 상태 (commit 시 DELETE SQL 실행)
    em.remove(emp);
}</code></pre>
    <ul>
        <li><strong>EntityManager</strong>는 JPA에서 영속성 컨텍스트를 관리하는 핵심 객체이다.</li>
        <li>스프링 환경에서는 <code>@PersistenceContext</code> 또는 <code>@Autowired EntityManager</code>로 주입받는다.</li>
        <li><strong>em.persist()</strong> 호출 시 엔터티는 “영속성 컨텍스트에 등록”되어 관리 상태가 된다.</li>
    </ul>

</section>

<section>
    <h2>6) 영속성 컨텍스트의 장점</h2>
    <ul>
        <li><strong>성능 향상</strong>: 같은 트랜잭션 내 중복 조회를 방지하여 DB 부하 감소</li>
        <li><strong>트랜잭션 일관성</strong>: 같은 엔터티에 대한 수정이 자동으로 반영됨</li>
        <li><strong>자동 업데이트</strong>: 개발자가 UPDATE SQL을 직접 작성하지 않아도 됨 (Dirty Checking)</li>
    </ul>
</section>

<section>
    <h2>7) 영속성 컨텍스트의 위험 (동시성 문제)</h2>
    <ul>
        <li>JPA는 “트랜잭션 범위 내에서” 데이터의 일관성을 유지하지만, <strong>다른 트랜잭션(사용자)</strong>이 같은 데이터를 변경할 경우
            <strong>내 컨텍스트는 그 사실을 모른다.</strong></li>
        <li>즉, 현재 영속성 컨텍스트에 캐싱된 데이터가 최신 DB 상태와 다를 수 있다.</li>
        <li>이 경우 “더티 리드(Dirty Read)” 또는 “Lost Update(갱신 손실)” 같은 문제가 발생할 수 있다.</li>
    </ul>
    <pre><code>// A 트랜잭션
Emp emp = empRepository.findById(7788).get(); // 영속성 컨텍스트에 캐싱됨
emp.setSal(3000);

// B 트랜잭션이 같은 사원 급여를 5000으로 변경 후 커밋

// A가 뒤늦게 commit 하면, 3000으로 덮어씌움 (갱신 손실 발생)</code></pre>
    <ul>
        <li><strong>해결 방법</strong>:
            <ul>
                <li>Optimistic Lock(낙관적 락): <code>@Version</code> 필드를 사용하여 수정 시 버전 비교</li>
                <li>Pessimistic Lock(비관적 락): DB 수준에서 SELECT FOR UPDATE 사용</li>
                <li>또는 트랜잭션 범위를 짧게 유지하여 동시성 구간 최소화</li>
            </ul>
        </li>
    </ul>
</section>

<section>
    <h2>8) 요약</h2>
    <ul>
        <li><strong>영속성 컨텍스트:</strong> 엔터티를 1차 캐시에 저장하고 관리하는 JPA의 핵심 구조</li>
        <li><strong>주요 기능:</strong> 1차 캐시, 쓰기 지연, 변경 감지(Dirty Checking), 동일성 보장</li>
        <li><strong>save() 실행 시:</strong> persist/merge를 통해 영속 상태 등록, commit 시점에 DB 반영</li>
        <li><strong>주의사항:</strong> 트랜잭션 단위로만 유효, 다른 사용자 변경은 자동 반영되지 않음</li>
        <li><strong>해결책:</strong> Lock 사용 또는 짧은 트랜잭션 유지로 동시성 제어</li>
    </ul>
</section>
</body>
</html>