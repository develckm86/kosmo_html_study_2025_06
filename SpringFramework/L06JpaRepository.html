<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>Spring Data JPA Repository </title>
    <link rel="stylesheet" href="/src/css/study.css">

</head>
<body>
<h1>Spring Data JPA Repository </h1>
<section>
    <h2>1) JpaRepository 개요</h2>
    <ul>
        <li><strong>JpaRepository</strong>는 Spring Data JPA가 제공하는 인터페이스로,
            CRUD, 페이징, 정렬 기능을 모두 포함한 <strong>Repository의 상위 인터페이스</strong>이다.
        </li>
        <li>일반적으로 <code>public interface XxxRepository extends JpaRepository&lt;Entity, ID&gt;</code> 형태로 상속한다.</li>
        <li>내부적으로 EntityManager를 통해 SQL을 자동 생성하고 실행한다.</li>
        <li>개발자는 직접 SQL을 작성하지 않고, 메서드 이름만으로 쿼리를 자동 생성할 수 있다.</li>
    </ul>
</section>

<section>
    <h2>2) JpaRepository 기본 메서드</h2>
    <ul>
        <li><strong>저장/수정</strong>
            <ul>
                <li><code>S save(S entity)</code> : 새 엔터티는 INSERT, 기존 엔터티는 UPDATE</li>
                <li><code>List&lt;S&gt; saveAll(Iterable&lt;S&gt; entities)</code></li>
                <li><code>void flush()</code> : 영속성 컨텍스트 즉시 DB 반영</li>
                <li><code>S saveAndFlush(S entity)</code> : 저장 후 즉시 flush</li>
            </ul>
        </li>
        <li><strong>조회</strong>
            <ul>
                <li><code>Optional&lt;T&gt; findById(ID id)</code> : ID로 단건 조회 (없으면 Optional.empty())</li>
                <li><code>List&lt;T&gt; findAll()</code> : 전체 조회</li>
                <li><code>List&lt;T&gt; findAll(Sort sort)</code> : 정렬 조회</li>
                <li><code>Page&lt;T&gt; findAll(Pageable pageable)</code> : 페이징 조회</li>
                <li><code>List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids)</code></li>
                <li><code>T getReferenceById(ID id)</code> : 프록시 객체 조회 (지연 로딩)</li>
            </ul>
        </li>
        <li><strong>존재/개수</strong>
            <ul>
                <li><code>boolean existsById(ID id)</code></li>
                <li><code>long count()</code></li>
            </ul>
        </li>
        <li><strong>삭제</strong>
            <ul>
                <li><code>void deleteById(ID id)</code></li>
                <li><code>void delete(T entity)</code></li>
                <li><code>void deleteAll(Iterable&lt;? extends T&gt; entities)</code></li>
                <li><code>void deleteAll()</code></li>
                <li><code>void deleteInBatch(Iterable&lt;T&gt; entities)</code>, <code>void deleteAllInBatch()</code></li>
            </ul>
        </li>
    </ul>
</section>

<section>
    <h2>3) 파생 쿼리(Derived Query) 작성 규칙</h2>
    <ul>
        <li><strong>메서드명은 엔터티의 필드명을 기준으로 작성</strong>한다. (DB 컬럼명 아님)</li>
        <li><strong>접두사</strong>: findBy, readBy, getBy, countBy, existsBy, deleteBy</li>
        <li><strong>연산자</strong>:
            <ul>
                <li>논리연결: And, Or</li>
                <li>비교/범위: Between, LessThan, LessThanEqual, GreaterThan, GreaterThanEqual</li>
                <li>문자열: Like, NotLike, Containing, StartingWith, EndingWith, IgnoreCase</li>
                <li>널/불리언: IsNull, IsNotNull, True, False</li>
                <li>컬렉션: In, NotIn</li>
                <li>정렬/상위: OrderBy필드Asc/Desc, TopN, First</li>
            </ul>
        </li>
        <li><strong>예시</strong>:
            <pre><code>public interface EmpRepository extends JpaRepository&lt;Emp, Integer&gt; {
  List&lt;Emp&gt; findByDeptno(Integer deptno);
  List&lt;Emp&gt; findByJobAndDeptno(String job, Integer deptno);
  List&lt;Emp&gt; findByEnameContainingIgnoreCase(String keyword);
  List&lt;Emp&gt; findBySalBetween(Double min, Double max);
  List&lt;Emp&gt; findTop3ByDeptnoOrderBySalDesc(Integer deptno);
}</code></pre>
        </li>
    </ul>
</section>

<section>
    <h2>4) Optional 반환</h2>
    <ul>
        <li><strong>Optional이란?</strong> 값이 존재할 수도, 존재하지 않을 수도 있음을 표현하는 컨테이너 클래스 (Java 8+)</li>
        <li><strong>JPA에서 Optional 반환:</strong>
            <ul>
                <li><code>findById()</code>는 기본적으로 <code>Optional&lt;T&gt;</code>을 반환한다.</li>
                <li>단건을 보장하는 파생쿼리에도 Optional을 직접 지정할 수 있다.</li>
            </ul>
        </li>
        <li><strong>사용 예시:</strong>
            <pre><code>Optional&lt;Emp&gt; opt = empRepository.findById(7788);

// 1) 값이 있으면 반환, 없으면 예외
Emp emp = opt.orElseThrow(() -&gt; new NoSuchElementException("사원 없음"));

// 2) 기본값 지정
Emp emp2 = empRepository.findById(9999)
             .orElse(new Emp(9999, "UNKNOWN", "NONE"));

// 3) 존재 시 실행
empRepository.findById(7788)
             .ifPresent(e -&gt; System.out.println(e.getEname()));</code></pre>
        </li>
        <li><strong>주의사항:</strong>
            <ul>
                <li><code>get()</code> 직접 호출은 권장하지 않음(비어있으면 예외 발생)</li>
                <li>Optional은 엔터티 필드 타입으로 사용하지 않는다.</li>
            </ul>
        </li>
    </ul>
</section>

<section>
    <h2>5) @Query 사용 (직접 쿼리 작성)</h2>
    <h3>5-1) JPQL (ORM 기반)</h3>
    <ul>
        <li>엔터티와 필드명을 기준으로 작성한다. (테이블/컬럼명 X)</li>
        <li>변수 바인딩: <code>:이름</code> 또는 <code>?1</code></li>
        <li>반환 타입: 엔터티, DTO, Projection 가능</li>
    </ul>
    <pre><code>@Query("SELECT e FROM Emp e WHERE e.deptno = :deptno AND e.sal BETWEEN :min AND :max ORDER BY e.sal DESC")
List&lt;Emp&gt; findRichInDept(@Param("deptno") Integer deptno,
                          @Param("min") Double min,
                          @Param("max") Double max);</code></pre>

    <h3>5-2) Native SQL (DB 전용 문법)</h3>
    <ul>
        <li>DB 테이블/컬럼명을 그대로 사용한다. (예: EMP, SAL)</li>
        <li>Oracle 전용 문법(ROWNUM, FETCH FIRST 등) 사용 가능</li>
    </ul>
    <pre><code>@Query(value = "SELECT * FROM EMP WHERE DEPTNO = :deptno ORDER BY SAL DESC FETCH FIRST :n ROWS ONLY",
       nativeQuery = true)
List&lt;Emp&gt; topEarnersInDept(@Param("deptno") Integer deptno, @Param("n") int n);</code></pre>
</section>

<section>
    <h2>6) 함수명 작성 규칙 요약</h2>
    <ul>
        <li><strong>항상 엔터티의 필드명 기준</strong>으로 작성한다.</li>
        <li>DB 컬럼명과 다를 경우 <code>@Column(name="...")</code>으로 매핑만 조정한다.</li>
        <li><strong>올바른 예:</strong> <code>findByHiredateBetween</code>, <code>findByEnameContaining</code></li>
        <li><strong>잘못된 예:</strong> <code>findByHIREDATEBetween</code>, <code>findByENAMEContaining</code></li>
    </ul>
</section>

<section>
    <h2>7) 실전 팁</h2>
    <ul>
        <li><strong>Like 검색:</strong> <code>findByEnameContainingIgnoreCase</code></li>
        <li><strong>날짜 범위:</strong> <code>findByHiredateBetween(Date s, Date e)</code></li>
        <li><strong>페이징:</strong> Pageable 사용 (PageRequest.of(페이지, 크기, Sort))</li>
        <li><strong>벌크 연산:</strong> <code>@Modifying @Transactional</code> 필수</li>
        <li><strong>복잡한 쿼리:</strong> @Query 또는 Querydsl로 처리</li>
    </ul>
</section>

<section>
    <h2>8) 전체 요약</h2>
    <ul>
        <li><strong>JpaRepository:</strong> JPA의 기본 CRUD + 페이징 + 정렬 인터페이스</li>
        <li><strong>파생 쿼리:</strong> 메서드 이름만으로 자동 SQL 생성</li>
        <li><strong>Optional:</strong> null 대신 안전한 결과 처리</li>
        <li><strong>@Query(JPQL/Native):</strong> 자동 생성이 어려운 경우 직접 작성</li>
        <li><strong>함수명 규칙:</strong> 엔터티 필드명 기준으로 작성 (DB 컬럼명 X)</li>
        <li><strong>Oracle 예시:</strong> FETCH FIRST, ROWNUM, ORDER BY, BETWEEN 등 사용 가능</li>
    </ul>
</section>
</body>
</html>