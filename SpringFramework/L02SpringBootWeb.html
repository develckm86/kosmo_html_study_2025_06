<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Spring Boot Web</title>
    <link rel="stylesheet" href="/src/css/study.css">

</head>
<body>
    <h1>Spring Boot Web</h1>
    <section>
        <h2>1. 스프링 부트 Web 프로젝트 구조</h2>
        <ul>
            <li><strong>프로젝트 생성:</strong> <code>Spring Initializr</code> (start.spring.io) 사용
                <ul>
                    <li>Dependencies: Spring Web, Thymeleaf, DevTools</li>
                    <li>빌드 도구: Maven 또는 Gradle</li>
                </ul>
            </li>
            <li><strong>폴더 구조 설명:</strong>
                <ul>
                    <li><code>src/main/java</code>: 자바 소스 (Controller, Service, Repository)</li>
                    <li><code>src/main/resources/static</code>: 정적 리소스 (css, js, img)</li>
                    <li><code>src/main/resources/templates</code>: 뷰 템플릿(Thymeleaf HTML 파일)</li>
                    <li><code>src/main/resources/application.properties</code>: 환경 설정 파일</li>
                </ul>
            </li>
            <li><strong>DevTools:</strong> 코드 또는 템플릿 변경 시 자동 리로드 및 반영 지원.</li>
        </ul>
    </section>

    <section>
        <h2>2. Spring Boot의 App 클래스와 main 함수</h2>
        <ul>
            <li><strong>Spring Boot의 시작점:</strong> 모든 애플리케이션은 <code>@SpringBootApplication</code>이 선언된 클래스에서 시작.</li>
            <li><strong>main 함수 역할:</strong> <code>SpringApplication.run()</code>이 내부적으로 스프링 컨테이너를 생성하고, 내장 톰캣을 실행함.</li>
            <li><strong>특징:</strong> 외부 서버 배포 없이 실행 가능(자동 내장 서버 구동).</li>
        </ul>
        <pre><code>@SpringBootApplication
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}</code></pre>
        <ul>
            <li>main 함수가 실행되면 다음 단계가 수행됨:
                <ol>
                    <li>SpringApplication이 <strong>IoC 컨테이너(ApplicationContext)</strong>를 생성</li>
                    <li>@Controller, @Service, @Repository 등의 Bean 자동 스캔</li>
                    <li>내장 Tomcat 서버 실행 후 <code>8080</code> 포트에서 대기</li>
                </ol>
            </li>
        </ul>
    </section>

    <section>
        <h2>3. 기존 WAR 배포 방식과의 차이</h2>
        <ul>
            <li><strong>전통적 스프링(WAR 방식):</strong>
                <ul>
                    <li>Tomcat, Jetty 등의 WAS(Web Application Server)에 war 파일을 직접 배포.</li>
                    <li>웹.xml, DispatcherServlet, context 설정 파일을 수동으로 구성해야 함.</li>
                    <li>개발자가 직접 서버 설치 및 설정 필요.</li>
                </ul>
            </li>
            <li><strong>Spring Boot 방식(JAR 실행):</strong>
                <ul>
                    <li>내장 서버(Tomcat, Jetty 등)가 포함된 <code>JAR</code> 형태로 실행.</li>
                    <li><code>java -jar app.jar</code> 명령만으로 서버 실행 가능.</li>
                    <li>별도의 WAS 설치, web.xml 설정 불필요.</li>
                    <li>자동 설정(Auto Configuration)과 Starter 의존성으로 개발 단순화.</li>
                </ul>
            </li>
            <li><strong>요약 비교:</strong>
                <ul>
                    <li>WAR: 외부 WAS 필요, 수동 설정 다수</li>
                    <li>BOOT(JAR): 내장 WAS 포함, 자동 설정 중심</li>
                </ul>
            </li>
        </ul>
    </section>

    <section>
        <h2>4. @Controller와 View 렌더링 구조</h2>
        <ul>
            <li><strong>@Controller:</strong> 요청을 받아 로직을 처리하고 View로 결과 전달.</li>
            <li><strong>View Resolver:</strong> 컨트롤러가 반환한 문자열을 실제 HTML 경로로 매핑.</li>
            <li><strong>Thymeleaf 경로 매핑:</strong>
                <ul>
                    <li>Controller에서 <code>return "index";</code> → <code>src/main/resources/templates/index.html</code> 렌더링.</li>
                    <li>전통적인 MVC의 <code>WEB-INF/views</code>를 <code>classpath:/templates/</code> 경로로 대체.</li>
                </ul>
            </li>
        </ul>
        <pre><code>@Controller
public class HomeController {

    @GetMapping("/")
    public String home() {
        return "index"; // templates/index.html
    }
}</code></pre>
    </section>

    <section>
        <h2>5. 컨트롤러 함수의 동작 원리</h2>
        <ul>
            <li><strong>1) DispatcherServlet:</strong> 모든 요청을 받아 컨트롤러로 전달.</li>
            <li><strong>2) HandlerMapping:</strong> 요청 URL과 매핑된 컨트롤러 탐색.</li>
            <li><strong>3) Controller:</strong> 로직 처리 후 Model에 데이터 저장.</li>
            <li><strong>4) ViewResolver:</strong> 뷰 이름을 템플릿 경로로 변환.</li>
            <li><strong>5) Thymeleaf:</strong> Model 데이터를 HTML에 반영하여 렌더링.</li>
        </ul>
        <pre><code>요청 → DispatcherServlet → Controller → Model → ViewResolver → Thymeleaf(View) → 응답</code></pre>
    </section>

    <section>
        <h2>6. 요청 파라미터 받는 방법</h2>
        <ul>
            <li><strong>@RequestParam:</strong> 쿼리 파라미터로 전달된 값 받기.</li>
            <li><strong>@PathVariable:</strong> URL 경로의 일부를 변수로 받기.</li>
            <li><strong>@ModelAttribute:</strong> Form 데이터를 객체로 자동 매핑.</li>
        </ul>
        <pre><code>@Controller
public class UserController {

    @GetMapping("/hello")
    public String hello(@RequestParam("name") String name, Model model) {
        model.addAttribute("userName", name);
        return "hello";
    }

    @GetMapping("/user/{id}")
    public String getUser(@PathVariable("id") Long id, Model model) {
        model.addAttribute("userId", id);
        return "user-detail";
    }
}</code></pre>
    </section>

    <section>
        <h2>7. Model을 통한 데이터 전달과 View 렌더링</h2>
        <ul>
            <li><strong>Model 객체:</strong> 컨트롤러에서 View로 데이터를 전달하는 저장소.</li>
            <li><strong>addAttribute("이름", 값):</strong> Thymeleaf에서 <code>${이름}</code>으로 접근.</li>
        </ul>
        <pre><code>@Controller
public class ProductController {

    @GetMapping("/product")
    public String product(Model model) {
        model.addAttribute("name", "노트북");
        model.addAttribute("price", 1500000);
        return "product"; // templates/product.html
    }
}</code></pre>

        <p><strong>템플릿 (product.html):</strong></p>
        <pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns:th="http://www.thymeleaf.org"&gt;
&lt;body&gt;
  &lt;h1 th:text="'상품명: ' + ${name}"&gt;&lt;/h1&gt;
  &lt;p th:text="'가격: ' + ${price}"&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
    </section>

    <section>
        <h2>8. Thymeleaf와 템플릿 경로 구조</h2>
        <ul>
            <li><strong>템플릿 기본 위치:</strong> <code>src/main/resources/templates/</code></li>
            <li><strong>전통적인 WEB-INF 구조 대체:</strong>
                <ul>
                    <li>기존 스프링 MVC: <code>WEB-INF/views/</code></li>
                    <li>Spring Boot: <code>classpath:/templates/</code></li>
                    <li>실행 시 <code>ViewResolver</code>가 자동으로 해당 경로를 찾음.</li>
                </ul>
            </li>
            <li><strong>정적 리소스 경로:</strong> <code>src/main/resources/static/</code>의 파일은 컨트롤러 없이 직접 접근 가능.</li>
        </ul>
    </section>

    <section>
        <h2>9. 요약</h2>
        <ul>
            <li>Spring Boot는 main 함수(App 클래스)에서 내장 서버를 직접 실행한다.</li>
            <li>기존 WAR 방식은 외부 서버 필요하지만 Boot는 JAR 자체 실행 구조이다.</li>
            <li>@Controller가 요청을 처리하고 Model을 통해 View에 데이터 전달한다.</li>
            <li>Thymeleaf는 templates 디렉토리에서 HTML을 렌더링하며, WEB-INF의 역할을 대체한다.</li>
            <li>DevTools로 자동 리로드가 가능해 실습 효율이 높다.</li>
        </ul>
    </section>
</body>
</html>