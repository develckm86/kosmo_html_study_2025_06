<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>MVC와 Model2 구조 수업(보강본)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="stylesheet" href="/src/css/study.css">

</head>
<body>
<h1>디자인패턴 MVC와 Model2 구조</h1>

<section>
    <h2>1. 디자인패턴이란?</h2>
    <ul>
        <li>소프트웨어 설계에서 반복적으로 등장하는 문제를 해결하기 위한 검증된 설계 템플릿의 모음</li>
        <li>코드가 아니라 “구조와 책임 분배”에 대한 합의된 방식</li>
        <li>MVC 패턴은 대표적인 UI 애플리케이션 구조 패턴으로, 웹 애플리케이션에서 폭넓게 사용된다</li>
    </ul>
</section>

<section>
    <h2>2. MVC 패턴이란?</h2>
    <ul>
        <li><strong>Model</strong>: 데이터와 비즈니스 로직(예: DTO, DAO, Service 등)과 상태 변경 규칙을 담당</li>
        <li><strong>View</strong>: 사용자에게 데이터를 표시하는 계층(JSP/HTML/CSS)</li>
        <li><strong>Controller</strong>: 요청을 해석해 적절한 Model을 호출하고 View로 연결하는 흐름 제어</li>
        <li>목표: 역할을 분리해 응집도↑, 결합도↓, 테스트 용이성 및 유지보수성 향상</li>
    </ul>
</section>

<section>
    <h2>3. Model1 vs Model2 핵심 차이</h2>
    <ul>
        <li><strong>Model1</strong>: JSP가 요청을 직접 받고 로직/DB까지 처리 → 화면·로직 혼재, 구조 단순하지만 확장성/재사용성 제한</li>
        <li><strong>Model2(MVC)</strong>: Controller(Servlet)가 요청을 받고 Service/DAO로 위임, JSP는 출력 전담 → 역할 분리로 유지보수/테스트 유리</li>
        <li><strong>요청 흐름(Model1)</strong>: Client → JSP(로직·DB·출력)</li>
        <li><strong>요청 흐름(Model2)</strong>: Client → Controller → Service → DAO → DB → Service → Controller → JSP(View)</li>
    </ul>
</section>

<section>
    <h2>4. 프로젝트 기획 순서</h2>
    <ul>
        <li><strong>1) 기능 기획</strong>: 구현 범위·핵심 유스케이스 정의(예: 사원 목록/상세/등록/수정/삭제)</li>
        <li><strong>2) View와 서비스 설계</strong>: 화면 목록, UI 흐름, 각 화면이 요구하는 서비스 동작 정의</li>
        <li><strong>3) DB 선택</strong>: 사용 DBMS 결정(Oracle/MySQL 등), 접속 환경·계정 정책 확정</li>
        <li><strong>4) DB 설계</strong>: 테이블/관계/식별자/제약 정의(예: EMP/DEPT 스키마)</li>
        <li><strong>5) DTO, DAO 설계</strong>: 데이터 전달 객체와 데이터 접근 계층의 인터페이스/메서드 시그니처 정의</li>
        <li><strong>6) Connection 구현</strong>: 연결 팩토리 또는 커넥션 풀 구성(성능·자원 관리 기준 수립)</li>
        <li><strong>7) DAO 구현</strong>: SQL과 매핑, 트랜잭션 경계 고려한 CRUD 로직 구현</li>
        <li><strong>8) Service 및 Bean 구현</strong>: 비즈니스 규칙·검증·복합 트랜잭션 처리, DAO 조합</li>
        <li><strong>9) Controller 구현(서비스 호출)</strong>: 요청 파라미터 → Service 호출 → 모델 데이터 바인딩 → View 포워드</li>
        <li><strong>10) View 처리</strong>: JSP에서 전달받은 모델 데이터 표시(출력 전담, 로직 최소화)</li>
    </ul>
</section>

<section>
    <h2>5. 역할 정리</h2>
    <ul>
        <li><strong>Controller</strong>: 라우팅/흐름 제어, 파라미터 검증, Service 호출, View 선택</li>
        <li><strong>Service</strong>: 도메인 규칙·검증·트랜잭션 조율, 여러 DAO 조합</li>
        <li><strong>DAO</strong>: SQL 실행·결과 매핑, 영속성 처리</li>
        <li><strong>DTO</strong>: 계층 간 데이터 전달을 위한 단순 객체</li>
        <li><strong>View(JSP)</strong>: 표현 전담(반복/조건 정도만), 비즈니스 로직 배제</li>
        <li><strong>DB</strong>: 데이터 영속화와 무결성 보장</li>
    </ul>
</section>

<section>
    <h2>6. 전체 흐름(요청/응답)</h2>
    <ul>
        <li><strong>요청</strong>: Client → Controller → Service → DAO → DB</li>
        <li><strong>응답</strong>: DB → DAO → Service → Controller → View(JSP)</li>
        <li>각 단계는 입력·출력 계약(파라미터·DTO·예외 처리)을 명확히 한다</li>
    </ul>
</section>

<section>
    <h2>7. 수업 핵심 포인트</h2>
    <ul>
        <li>Model2는 MVC 패턴의 표준적 웹 구현 형태로, 실무 프레임워크(Spring MVC 등)의 기초</li>
        <li>Controller/Service/DAO/JSP 간 책임 분리가 유지보수성과 테스트 용이성을 만든다</li>
        <li>“기획 → 설계 → 구현” 순서를 지키면 변경 요구에도 구조가 흔들리지 않는다</li>
    </ul>
</section>
</body>
</html>