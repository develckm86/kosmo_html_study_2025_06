<!DOCTYPE html>


<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>JUnit 5 단위 테스트 개요</title>
    <link rel="stylesheet" href="/src/css/study.css">

</head>
<body>
<h1>JUnit 5 단위 테스트 개요</h1>


<section>
    <h2>JUnit이란 무엇인가</h2>
    <ul>
        <li>JUnit은 자바 단위 테스트(Unit Test)를 위한 대표적인 테스트 프레임워크이다.</li>
        <li>메서드 단위로 코드를 검증하고, 예상한 결과와 실제 결과가 같은지 자동으로 확인해준다.</li>
        <li>Maven, Gradle과 쉽게 통합되고, IDE(인텔리제이, 이클립스)에서 바로 실행할 수 있다.</li>
        <li>JUnit 5부터는 구조가 모듈화되어 있고, 자바 8 이상의 기능(람다, 어노테이션 개선)을 적극 활용한다.</li>
    </ul>
</section>


<section>
    <h2>JUnit 5의 전체 구조</h2>
    <ul>
        <li>JUnit 5는 크게 세 부분으로 나뉜다.</li>
        <li>- JUnit Platform: 테스트를 실행하는 플랫폼. IDE, Gradle, Maven 같은 외부 도구가 이 플랫폼을 통해 테스트를 실행한다.</li>
        <li>- JUnit Jupiter: 실제로 사용하는 JUnit 5 어노테이션(@Test 등)과 테스트 API가 들어 있는 부분.</li>
        <li>- JUnit Vintage: JUnit 3, 4로 작성한 예전 테스트를 JUnit 5에서 같이 돌리고 싶을 때 쓰는 호환 모듈.</li>
        <li>즉, Platform이 실행기, Jupiter가 실제 JUnit 5 테스트, Vintage는 옛 코드 지원이라고 보면 된다.</li>
    </ul>
</section>


<section>
    <h2>JUnit 엔진 동작 방식</h2>
    <ul>
        <li>1) IDE나 빌드 도구가 JUnit Platform에 테스트 실행을 요청한다.</li>
        <li>2) Platform은 내부에 등록된 테스트 엔진(Test Engine)을 찾는다.</li>
        <li>3) 우리가 JUnit 5(Jupiter)로 만든 테스트 클래스는 Jupiter 테스트 엔진이 분석한다.</li>
        <li>4) 엔진은 클래스에 붙은 어노테이션(@Test, @BeforeEach 등)을 읽어서 실행 순서를 만든다.</li>
        <li>5) 설정 메서드(@BeforeAll) → 테스트 메서드(@Test) → 해제 메서드(@AfterEach) 순서로 호출하며, 결과를 Platform으로 전달한다.</li>
        <li>6) Platform은 성공, 실패, 스킵 정보를 IDE에 넘겨서 우리가 보는 녹색/빨간 표시를 만든다.</li>
        <li>핵심: 어노테이션 기반으로 실행 순서를 구성하고, 테스트 엔진이 여러 개일 수 있다.</li>
    </ul>
</section>


<section>
    <h2>JUnit 5에서 자주 사용하는 어노테이션</h2>
    <ul>
        <li>- @Test
            <ul>
                <li>가장 기본 테스트 메서드.</li>
                <li>반환형은 void.</li>
            </ul>
        </li>
        <li>- @DisplayName("설명")
            <ul>
                <li>테스트 이름을 사람이 보기 좋게 바꿈.</li>
                <li>수업용 테스트는 한글로 의미 있는 이름을 주면 이해가 쉽다.</li>
            </ul>
        </li>
        <li>- @BeforeAll
            <ul>
                <li>테스트 클래스 전체에서 딱 한 번만 실행.</li>
                <li>DB 연결 풀 초기화, 공통 리소스 준비.</li>
                <li>static 메서드여야 한다.</li>
            </ul>
        </li>
        <li>- @AfterAll
            <ul>
                <li>테스트 클래스가 전부 끝난 후 딱 한 번 실행.</li>
                <li>리소스 정리, 커넥션 닫기.</li>
                <li>static 메서드여야 한다.</li>
            </ul>
        </li>
        <li>- @BeforeEach
            <ul>
                <li>각 테스트 메서드 실행 직전에 실행.</li>
                <li>각 테스트가 항상 “깨끗한 상태”로 시작하도록 준비.</li>
            </ul>
        </li>
        <li>- @AfterEach
            <ul>
                <li>각 테스트 메서드 실행 직후에 실행.</li>
                <li>테스트 중 생성한 임시 데이터, 파일, 목 객체 제거.</li>
            </ul>
        </li>
        <li>- @Disabled
            <ul>
                <li>해당 테스트를 일시적으로 비활성화.</li>
                <li>아직 구현하지 않았거나, 외부 시스템이 준비 안 된 테스트.</li>
            </ul>
        </li>
    </ul>
</section>


<section>
    <h2>JUnit 5에서 사용할 수 있는 테스트 종류(스타일)</h2>
    <ul>
        <li>- 단위 테스트(Unit Test)
            <ul>
                <li>가장 기본적인 테스트.</li>
                <li>하나의 메서드, 하나의 기능이 기대한 대로 동작하는지 확인.</li>
            </ul>
        </li>
        <li>- 파라미터화 테스트(Parameterized Test)
            <ul>
                <li>@ParameterizedTest와 @ValueSource, @CsvSource 등을 사용.</li>
                <li>같은 테스트 로직을 여러 입력값에 대해 반복 실행.</li>
                <li>문자열 파싱, 비밀번호 검증처럼 케이스가 많은 수업에서 유용.</li>
            </ul>
        </li>
        <li>- 반복 테스트(Repeated Test)
            <ul>
                <li>@RepeatedTest 사용.</li>
                <li>동일 테스트를 여러 번 돌려서 간헐적 오류나 성능 문제를 확인.</li>
            </ul>
        </li>
        <li>- 조건부 테스트(Conditional Test)
            <ul>
                <li>@EnabledOnOs, @DisabledOnJre 등.</li>
                <li>OS, JDK 버전, 환경변수에 따라 테스트를 켜고 끔.</li>
                <li>CI/CD나 도커 환경 실습에서 “윈도우일 때만 실행” 같은 조건 걸 때 사용.</li>
            </ul>
        </li>
        <li>- 예외 테스트
            <ul>
                <li>assertThrows(...)를 사용해서 특정 코드가 예외를 던지는지 검증.</li>
                <li>파라미터 검증, 유효성 검사 수업과 연결하기 좋다.</li>
            </ul>
        </li>
    </ul>
</section>


<section>
    <h2>대표적인 단언(assert) 메서드</h2>
    <ul>
        <li>- assertEquals(expected, actual)
            <ul>
                <li>기대한 값과 실제 값이 같은지 확인.</li>
            </ul>
        </li>
        <li>- assertTrue(condition), assertFalse(condition)
            <ul>
                <li>조건이 참/거짓인지 확인.</li>
            </ul>
        </li>
        <li>- assertThrows(예외클래스, 실행블록)
            <ul>
                <li>실행했을 때 반드시 예외가 발생해야 테스트가 성공.</li>
            </ul>
        </li>
        <li>- assertAll(…)
            <ul>
                <li>여러 검증을 한 번에 묶어 실행.</li>
                <li>하나 실패해도 나머지를 실행해서 리포트를 풍부하게 만듦.</li>
            </ul>
        </li>
    </ul>
</section>


<section>
    <h2>예제 코드</h2>
    <pre><code>
import org.junit.jupiter.api.*;


class CalculatorTest {

@BeforeAll
static void initAll() {
    System.out.println("테스트 전체 준비");
}

@BeforeEach
void init() {
    System.out.println("각 테스트 준비");
}

@Test
@DisplayName("덧셈이 정상적으로 동작해야 한다")
void addTest() {
    int result = 2 + 3;
    Assertions.assertEquals(5, result);
}

@Test
@DisplayName("0으로 나누면 예외가 발생해야 한다")
void divideByZero() {
    Assertions.assertThrows(ArithmeticException.class, () -> {
        int x = 10 / 0;
    });
}

@AfterEach
void tearDown() {
    System.out.println("각 테스트 후처리");
}

@AfterAll
static void tearDownAll() {
    System.out.println("테스트 전체 종료");
}

}


</section>


<section>
    <h2>수업에서 강조할 내용</h2>
    <ul>
        <li>- JUnit 4와 5는 구조가 다르며, 5는 Platform + Engine 구조라는 점.</li>
        <li>- 실행 순서는 어노테이션을 기준으로 엔진이 결정한다는 점.</li>
        <li>- @BeforeEach, @AfterEach로 테스트 독립성을 확보해야 한다는 점.</li>
        <li>- 파라미터화 테스트를 한 번 보여주면 실무와 연결이 잘 된다.</li>
        <li>- assertThrows로 예외 테스트를 하면 입력 검증 수업과 자연스럽게 이어진다.</li>
    </ul>
</section>


</body>
</html>
